---
title: "2218_Yilong_mRNA_stressGranules_DESeq2"
output: html_notebook
toc: true
---

## Sample sheet

name    condition       group
m1      mock    All
m2      mock    All
m3      mock    All

s4su1   treat_4sU       Group1
s4su2   treat_4sU       Group1
s4su3   treat_4sU       Group1

s4UH1   treat_4sU_puroHigh      Group2
s4UL3   treat_4sU_puroHigh      Group2
s4UH3   treat_4sU_puroHigh      Group2

s4UL1   treat_4sU_puroLow       Group3
s4UL2   treat_4sU_puroLow       Group3
s4UH2   treat_4sU_puroLow       Group3

U1      treat_UVA       Group4
U2      treat_UVA       Group4
U3      treat_UVA       Group4


```{r, install-libraries}
##if (!requireNamespace("BiocManager", quietly = TRUE))
##	install.packages("BiocManager")

## Install eisaR
# BiocManager::install("eisaR")
# BiocManager::install("GenomicFeatures")
# BiocManager::install("TxDb.Hsapiens.UCSC.hg38.knownGene")   # see 'annotation' to figure out which object you need
# BiocManager::install("QuasR")
# BiocManager::install("gtools")
# BiocManager::install("ensembldb")
# delete?
#BiocManager::install("BiocParallel")

##BiocManager::install(c("tidyverse", "apeglm", "ashr"))
```

```{r, load-libraries}
suppressPackageStartupMessages(library(dplyr))
suppressPackageStartupMessages(library(eisaR))
suppressPackageStartupMessages(library(GenomicFeatures))
suppressPackageStartupMessages(library(TxDb.Hsapiens.UCSC.hg38.knownGene))  # geneID to symbol conversion and for annotation
suppressPackageStartupMessages(library(QuasR))
suppressPackageStartupMessages(library(gtools))            # to do alphanumeric sort on column names (+ stringAsFactors=F)
suppressPackageStartupMessages(library(ensembldb))
suppressPackageStartupMessages(library(edgeR))
suppressPackageStartupMessages(library(BiocParallel))
```

## YES

Load exon data and genebody (intron+exon) data.

```{r, load-count-data}
# # create the sample sheet for paired-end sequencing:
path_inDir <- "/data/processing2/balan_Yilong/project_2297_45nG7vuc_mRNA-seq"
counts_geneBody <- read.delim(paste0(path_inDir, "/analysis/", "featureCounts_geneBody_ss/counts.tsv"), header = TRUE, sep='\t', na.strings="NA", row.names = 1, stringsAsFactors = F)
counts_exon <- read.delim(paste0(path_inDir, "/analysis/", "featureCounts_exon_def/counts.tsv"), header = TRUE, sep='\t', na.strings="NA", row.names = 1, stringsAsFactors = F)

## alphanumeric sort of columns
counts_geneBody <- counts_geneBody[,gtools::mixedorder(colnames(counts_geneBody))]
counts_exon <- counts_exon[,gtools::mixedorder(colnames(counts_exon))]

##remove the version nr after each accession number (e.g. "ENSG00000278267.1" to "ENSG00000278267")
  #why doesn't this work?
    #row.names(counts_geneBody) <- gsub("\\..*","",row.names(counts_geneBody))  
    # this would work but I don't understand what is happening:
      # row.names(counts_geneBody) <- make.names(gsub("\\..*","",row.names(counts_geneBody)), unique=TRUE )
  
  # apparently this creates non-unique row names; how many?
    #table(duplicated(gsub("\\..*","",row.names(counts_geneBody))))   
  # I get 45 gene IDs that will become non-unique if I do it this way; which ones? 
    #row.names(counts_geneBody)[duplicated(gsub("\\..*","",row.names(counts_geneBody)))]   
  # all have '_PAR_Y' suffix. Check one of the names:
    #row.names(counts_geneBody[grepl(pattern="ENSG00000169100", row.names(counts_geneBody) ),])
      #  "ENSG00000169100.13"       "ENSG00000169100.13_PAR_Y"   
  # are sequences from Y chromosome and they seem empty
      # all(counts_geneBody[grepl(pattern="_PAR_Y", row.names(counts_geneBody) ),] == 0)    # TRUE
  # are all empty in the 'counts_exon' too?
      # all(counts_exon[grepl(pattern="_PAR_Y", row.names(counts_exon) ),] == 0)            # TRUE

## NOTES:
  # Since by normal definitions there is no Y chromosome in female tissue, PAR_Y quantifications should be ignored (excluding special cases such as intersex syndrome).
  # In male, however, I would suggest making the sum of counts for the X and PAR_Y transcripts. Since alternative splicing may generate different variants of the same "Ensembl-ID" transcript, quantification should account for the total of the isoforms.  
  
  # remove the all the '_PAR_Y' rows because are empty
less_counts_geneBody <- counts_geneBody[!row.names(counts_geneBody) %in% row.names(counts_geneBody[grepl(pattern="_PAR_Y", row.names(counts_geneBody) ),]),]
less_counts_exon <- counts_exon[!row.names(counts_exon) %in% row.names(counts_exon[grepl(pattern="_PAR_Y", row.names(counts_exon) ),]),]

  # remove the version number
  row.names(less_counts_geneBody) <- gsub("\\..*","",row.names(less_counts_geneBody))
  row.names(less_counts_exon) <- gsub("\\..*","", row.names(less_counts_exon))
```

Get intron counts:

```{r, intron-counts}
counts_introns = less_counts_geneBody - less_counts_exon
write.table(counts_introns, file=paste0(path_inDir, '/intron_analysis_bam/', 'counts_introns_from_featureCounts.tsv'), sep="\t", row.names=TRUE)

head(counts_introns)

# create condition factors
treat <- factor(c(rep("mock", 3), rep("s4su", 3), "s4UH", "s4UL", "s4UH", rep("s4UL", 2), "s4UH", rep("U", 3) ) )
```


```{r, sanity-check-values, eval=FALSE, include=FALSE}
# #sanity checks only for s1 sample:
# #counts_exon[counts_geneBody$m1 == 0,]["ENSG00000278267.1",]
# #dplyr::filter(counts_geneBody,counts_geneBody$m1==0 & counts_exon$m1 != 0)["ENSG00000278267.1",]
# 
# s1_counts_to_zero_in_geneBody <- dplyr::filter(counts_exon,counts_geneBody$m1 == 0 & counts_exon$m1 != 0) # 3 387
# #s1_genes_to_zero_in_geneBody <- row.names(s1_counts_to_zero_in_geneBody)
# 
# s1_counts_less_in_geneBody_than_exon <- dplyr::filter(counts_exon,counts_geneBody$s1 < counts_exon$s1)        # 3 807
# #s1_genes_less_in_geneBody_than_exon <- row.names(s1_counts_less_in_geneBody_than_exon)
# 
# #sort(s1_counts_to_zero_in_geneBody$s1, decreasing = TRUE)
#   #  [1] 78384  4028  3280  2150  2149  2136  2013  1962  1849  1811  1690  1627  1624 
# s1_counts_to_zero_in_geneBody_sort <- s1_counts_to_zero_in_geneBody[order(s1_counts_to_zero_in_geneBody$s1, decreasing=TRUE),]
# s1_counts_less_in_geneBody_than_exon_sort <- s1_counts_less_in_geneBody_than_exon[order(s1_counts_less_in_geneBody_than_exon$s1, decreasing=TRUE),]
# 
# #remove the version nr after each accession number (e.g. "ENSG00000278267.1" to "ENSG00000278267")
# row.names(s1_counts_to_zero_in_geneBody_sort) <- gsub("\\..*","",row.names(s1_counts_to_zero_in_geneBody_sort))
# row.names(s1_counts_less_in_geneBody_than_exon_sort) <- gsub("\\..*","", row.names(s1_counts_less_in_geneBody_than_exon_sort))
# 
# # Convert from ensembl.gene to gene.symbol   
# #keytypes(TxDb.Hsapiens.UCSC.hg38.knownGene)      -doesn't work
# #ENTREZID_TxDb <- keys(TxDb.Hsapiens.UCSC.hg38.knownGene, keytype = "GENEID")
# 
# # works
# #BiocManager::install("EnsDb.Hsapiens.v86")
# #suppressPackageStartupMessages(library(EnsDb.Hsapiens.v86))
# #supportedFilters(EnsDb.Hsapiens.v86)
# 
# s1_genes_to_zero_in_geneBody_sort <- ensembldb::select(EnsDb.Hsapiens.v86, keys=row.names(s1_counts_to_zero_in_geneBody_sort), keytype = "GENEID", columns = c("SYMBOL","GENEID"))
# s1_genes_less_in_geneBody_than_exon_sort <- ensembldb::select(EnsDb.Hsapiens.v86, keys=row.names(s1_counts_less_in_geneBody_than_exon_sort), keytype = "GENEID", columns = c("SYMBOL","GENEID"))
# 
# # the opposite: Convert from gene.symbol to ensembl.gene
# #geneID_s1_to_zero <- ensembldb::select(EnsDb.Hsapiens.v86, keys=geneSymbol_s1_to_zero$SYMBOL, keytype = "SYMBOL", columns = c("SYMBOL","GENEID"))
# 
# write.table(s1_genes_to_zero_in_geneBody_sort$SYMBOL, file=paste0(path_inDir, '/intron_analysis_bam/', 'geneSymbol_s1_to_zero'), sep="\t", row.names=FALSE, col.names=FALSE, quote=FALSE)
# write.table(s1_genes_less_in_geneBody_than_exon_sort$SYMBOL, file=paste0(path_inDir, '/intron_analysis_bam/', 'geneSymbol_s1_less'), sep="\t", row.names=FALSE, col.names=FALSE, quote=FALSE)
#####################################
```

```{r, get-intron-counts-and-set-neg-to-zero}
# # function for looking at genes that have a exon count > geneBody count: (NOT FINISHED-not needed)
# 
# for (a in 1:length(colnames(counts_geneBody))){
#   assign(
#     paste0(colnames(counts_geneBody[1]),"_counts_to_less_in_geneBody_than_exon"), 
#     dplyr::filter(counts_exon, counts_geneBody[1] < counts_exon[1]) )
#   assign(
#     paste0(colnames(counts_geneBody[1]),"_counts_to_less_in_geneBody_than_exon_sort"), 
#     get(paste0(colnames(counts_geneBody[1]),"_counts_to_less_in_geneBody_than_exon"))[order(get(paste0(colnames(counts_geneBody[1]),"_counts_to_less_in_geneBody_than_exon")), decreasing=TRUE),]  )
#   }
# 
# row.names(paste0(colnames(counts_geneBody),"_counts_to_less_in_geneBody_than_exon_sort")) <- gsub("\\..*","", row.names(paste0(colnames(counts_geneBody),"_counts_to_less_in_geneBody_than_exon_sort")))  
# 
# write.table(paste0(colnames(counts_geneBody),"_counts_to_less_in_geneBody_than_exon_sort"), file=paste0(path_inDir, '/intron_analysis_bam/', 'intron_count_from_featureCounts'), sep="\t", row.names=FALSE, col.names=FALSE, quote=FALSE)
```

Eisa doesn't work with negative values. So in this 1st attempt, set all negative values to zero.

```{r, fix-the-negative-values}
counts_introns[counts_introns<0] <- 0
write.table(counts_introns, file=paste0(path_inDir, '/intron_analysis_bam/', 'counts_introns_from_featureCounts_noNeg.tsv'), sep="\t", row.names=TRUE)
```



# run EISA
```{r, eisa}
# # it works only on 2 levels at a time!
# with modelSamples
res_s4su_vs_mock <- runEISA(  less_counts_exon[c(4:6, 1:3)], counts_introns[c(4:6, 1:3)], droplevels(treat[c(4:6, 1:3)])  )   # drops unused factor levels because EISA only takes 2 at a time

res_s4UH_vs_mock <- runEISA(   less_counts_exon[c(7,9,12, 1:3)], counts_introns[c(7,9,12, 1:3)], droplevels(treat[c(7,9,12, 1:3)])  )   
res_s4UL_vs_mock <- runEISA(   less_counts_exon[c(10,11,8, 1:3)], counts_introns[c(10,11,8, 1:3)], droplevels(treat[c(10,11,8, 1:3)])  )   
res_U_vs_mock <- runEISA(   less_counts_exon[c(13:15, 1:3)], counts_introns[c(13:15, 1:3)], droplevels(treat[c(13:15, 1:3)])  )   

res_4UH_vs_4UL <- runEISA(   less_counts_exon[c(7,9,12, 10,11,8)], counts_introns[c(7,9,12, 10,11,8)], droplevels(treat[c(7,9,12, 10,11,8)])  )  
```

```{r, ploEISA-sgRNA}
png(paste0(path_inDir, '/intron_analysis_bam/','eisa_plot_with4UHvs4HL.png'), width=1600, height=800, units = "px", bg = "white")

par(oma = c(3,4,4,1),    # margins for whole plot
    mar = c(3,4,3.2,1)  # margins for individual plots
    )

xl <- c(-12,12)
yl <- c(-8,8)

layout(matrix(c(1, 2, 3, 4, 5), 2, 3, byrow=TRUE))
# layout.show(6)

list_objects=list("res_s4su_vs_mock", "res_s4UH_vs_mock", "res_s4UL_vs_mock", "res_U_vs_mock", "res_4UH_vs_4UL")


for (i in 1:length(list_objects) ) {
  eisaR::plotEISA(get(list_objects[[i]]), maxFDR = 0.05, minLfc = 2,
                  xlim=xl, ylim=yl,
                  main=list_objects[[i]] , xlab='', ylab='',
                  cex.axis=1.5, cex.main=1.5)
  abline(h = 0, v = 0, col = "gray")
}

title(main = "EISA - intron-exon analysis, FDR < 0.05, LFC > 2",
      xlab = expression(paste(Delta,'intron (cond1-cond2)')),
      ylab = expression(paste(Delta,'exon (cond1-cond2)')),
      outer = TRUE, line = 1,
      cex.lab=2, cex.main=2)



dev.off()
```